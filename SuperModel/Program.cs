using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.OleDb;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace SuperModel
{
    /*
     -o:C:\dev\test\ODApiEdit\app\model 
     -n:OdApiEdit.model 
     -e:Owner,Product,User 
     -a:"C:\dev\test\D2\D2\bin\D2.dll" 
     -d:"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=D5;Data Source=." 
     -b:"OdApiEdit.model.Base"
         */

    class Program
    {
        const string Version = "1.0.6";
        const string fileheader = "/*\r\n\r\nAutogenerated by SuperModel.exe. v. " + Version + "\r\nCopyright 2014-2018, Christian Skovdal Andersen\r\nDo not edit this file manually, changes may be overwritten.\r\n\r\n*/\r\n\r\n";

        static string assembly;
        static string[] entities;
        static string outputDir;
        static string ns;
        static string idPropertyName;
        static string connStr;
        static string baseClass;
        static string[] validationColumns;
        static string[] columns;
        static bool quiet = false;
        //static bool excludeValidation = false;
        static bool includeMetaData = false;
        
        static int Main(string[] args)
        {
            int res = ParseArguments(args);

            if (!quiet)
                Console.WriteLine("SuperModel v. " + Version + "\nBy Christian Skovdal Andersen, 2014-2018.\n" +
                              "A utility for converting .Net classes or" +
                              " SQL Server database tables into Ext.JS data models.\n");
            if (res > 0)
                return res;

            try
            {

                Dictionary<string, dynamic> modelMap = new Dictionary<string, dynamic>();

                if (!string.IsNullOrEmpty(connStr))
                {
                    using (var connection = new OleDbConnection(connStr))
                    {
                        connection.Open();


                        List<dynamic> models = new List<dynamic>();
                        foreach (var tbl in entities)
                        {
                            dynamic model = BuildModelFromTable(connection, tbl);
                            models.Add(model);
                        }

                        AddAssociations(entities, models);

                        for (int i = 0; i < models.Count(); i++)
                        {
                            var tbl = entities[i];
                            var model = models[i];
                            modelMap.Add(tbl, model);
                        }

                        connection.Close();
                    }
                }

                if (!string.IsNullOrEmpty(assembly))
                {
                    Assembly assem = Assembly.LoadFrom(assembly);
                    Type[] types = assem.GetTypes();
                    var clsTypes = types.Where(t => t.IsClass);
                    var extClasses = clsTypes.Where(t => entities.Contains(t.Name));

                    foreach (var cls in extClasses)
                    {
                        dynamic model = BuildModelFromPoco(cls, idPropertyName);
                        modelMap.Add(cls.Name, model);
                    }
                }

                foreach (var tbl in modelMap.Keys)
                {           
                    WriteModel(tbl, modelMap[tbl]);
                }

            }
            catch (Exception ex)
            {
                ShowError(ex.Message);
                return -1;
            }

            if (!quiet)
                Console.WriteLine("Done!");
            return 0;

        }


        private static void WriteModel(string name, dynamic model)
        {


            StringBuilder sb = new StringBuilder();
            sb.Append(fileheader);
            sb.Append(string.Format("Ext.define('{0}.{1}',{2});", ns, name, SerializeWithoutQuote(model)));
            string fn = Path.Combine(outputDir, name + ".js");
            File.WriteAllText(fn, sb.ToString());
        }


        private static void Error(string errMsg)
        {
            Console.WriteLine(errMsg);
        }

        private static string SerializeWithoutQuote(dynamic value)
        {
            var serializer = JsonSerializer.Create(null);
            var stringWriter = new StringWriter();

            using (var jsonWriter = new JsonTextWriter(stringWriter))
            {
                jsonWriter.QuoteName = false;
                jsonWriter.Formatting = Formatting.Indented;
                jsonWriter.QuoteChar = '\'';
                serializer.Serialize(jsonWriter, value);
                return stringWriter.ToString();
            }
        }

        private static int ParseArguments(string[] args)
        {

            //validators = CommandLineUtil.HasFlag(args, "v");
            quiet = CommandLineUtil.HasFlag(args, "q");

            if (args.SingleOrDefault(a => a == "-?" || a == "/?") != null)
            {
                ShowError("");
                return 0;
            }
            if (!CommandLineUtil.ParseArg(args, "n", out ns))
            {
                ShowError("Missing the namespace parameter (-n)");
                return 7;
            }
            CommandLineUtil.ParseArg(args, "i", out idPropertyName);

            if (!CommandLineUtil.ParseArg(args, "o", out outputDir))
            {
                ShowError("Missing the output directory parameter (-o)");
                return 3;
            }
            if (!Directory.Exists(outputDir))
            {
                ShowError("The output directory '" + outputDir + "' was not found");
                return 4;
            }

            if (CommandLineUtil.ParseArg(args, "vx", out validationColumns))
            {
                //excludeValidation = true;
            }
            else if (!CommandLineUtil.ParseArg(args, "v", out validationColumns))
            {
                if (CommandLineUtil.HasFlag(args, "v"))
                {
                    validationColumns = new string[0];
                }
            }

            includeMetaData = CommandLineUtil.HasFlag(args, "m");

            CommandLineUtil.ParseArg(args, "x", out columns);
           
            if (!CommandLineUtil.ParseArg(args, "e", out entities))
            {
                ShowError("Missing the entities parameter (-e)");
                return 5;
            }
            if (entities.Count() <= 0)
            {
                ShowError("Valid class name information in the parameter string was not found");
                return 6;
            }

            if (CommandLineUtil.ParseArg(args, "a", out assembly))
            {
                if (!File.Exists(assembly))
                {
                    ShowError("The assembly file '" + assembly + "' was not found");
                    return 2;
                }
            }

            CommandLineUtil.ParseArg(args, "d", out connStr);

            if (!CommandLineUtil.ParseArg(args, "b", out baseClass))
            {
                baseClass = "Ext.data.Model";
            }

            return 0;
        }

        private static void ShowError(string msg)
        {
            Console.WriteLine(msg + "\r\n\r\nUsage:\r\n" +
                "-a:<path>\tPath to assembly dll\r\n" +
                "-o:<path>\tPath to output directory\r\n" +
                "-b:<name>\tName of base class for models. If omitted it defaults to Ext.data.Model\r\n" +
                "-e:<entities>\tComma separated list of entities to be autogenerated\r\n" +
                "-d:<data>\tDatabase connection string\r\n" +
                "-v:<fields>\tA comma separated list of field names of fields that should have validators. If empty all applicable fields get validators\r\n" +
                "-vx:<fields>\tA comma separated list of field names of fields that should have no validators.\r\n" +
                "-x:<fields>\tExclude field(s) with the specified names from the model\r\n" +
                "-q\tQuiet mode. Do not display banner\r\n" +
                "-t:<e>\tComma separated list of database tables or .Net entitites\r\n" +
                "-n:<namespace>\tNamespace name\r\n" +
                "-m:\tInclude table meta-data information on the model in the field 'tableMetaData'\r\n" +
                "-i:<id>\tName of ID field\r\n\r\n" +
                "Examples:\r\n" +
                "SuperModel -a:c:\\myapp\\bin\\myapp.dll -o:c:\\myapp\\js\\model -c:Customer,Company,Employee -n:MyApp\r\n\r\n" +
                "SuperModel -d:\"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=Foo;Data Source=myserver\\sqlexpress\" -o:c:\\myapp\\js\\model -t:Customer,Company,Employee -n:MyApp"
                );
        }

#region Assembly modelling



        private static dynamic BuildModelFromPoco(Type cls, string idPropertyName)
        {
            Console.WriteLine("Building model '" + cls.Name + "'");

            dynamic model  = new ExpandoObject();

            if (!HasAttr(model, "extend"))
                model.extend = baseClass;

            if (!HasAttr(model, "requires"))
                model.requires = new[] { "Ext.data.Field" };

            if (!string.IsNullOrEmpty(idPropertyName) && !HasAttr(model, "idProperty"))
                model.idProperty = idPropertyName;

            if (!HasAttr(model, "fields"))
                model.fields = new List<dynamic>();

            PropertyInfo[] properties = cls.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            foreach (var p in properties)
            {

                if (columns != null && columns.Contains(p.Name))
                {
                    continue;
                }

                List<dynamic> modelFields = model.fields;
                bool hasField = modelFields.SingleOrDefault(m => m.name == p.Name) != null;
                var isVirtual = p.GetGetMethod().IsVirtual;
                if (!hasField && !isVirtual)
                {
                    string tname = TypeNameFromPOCOType(p.PropertyType);
                    if (tname == null)
                    {
                        Console.WriteLine("\tTypename '" + p.PropertyType.ToString() + "' is not recognized");
                    }
                    else
                    {
                        dynamic mf = BuildField(p.Name, tname);
                        model.fields.Add(mf);
                    }
                }
            }

            return model;
        }

        static ExpandoObject BuildField(string prop, string type)
        {
            dynamic mf = new ExpandoObject();

            mf.name = prop;
            mf.type = type;
            mf.defaultValue = (object)null;
            if (type == "date")
                mf.dateFormat = (object)null;
            return mf;
        }

        private static string TypeNameFromPOCOType(Type type)
        {
            if (type == typeof(string))
                return "string";
            if (type == typeof(DateTime) || type == typeof(DateTime?))
                return "date";
            if (type == typeof(double) || type == typeof(double?))
                return "float";
            if (type == typeof(float) || type == typeof(float?))
                return "float";
            if (type == typeof(int) || type == typeof(int?))
                return "int";
            if (type == typeof(bool) || type == typeof(bool?))
                return "boolean";
            else
                return "auto";
        }


#endregion

#region Database modelleing

        private static void AddAssociations(string[] tables, List<dynamic> models)
        {

        }


        private static bool HasAttr(ExpandoObject expando, string key)
        {
            return ((IDictionary<string, Object>)expando).ContainsKey(key);
        }

        private static dynamic BuildModelFromTable(OleDbConnection connection, string tbl)
        {
            Console.WriteLine("Building model '"+tbl+"'");
            dynamic t = new ExpandoObject();

            t.extend = "Ext.data.Model";
            t.requires = new[] { "Ext.data.Field" };

            var fields = new List<dynamic>();
            var validators = new List<dynamic>();

            if (string.IsNullOrEmpty(idPropertyName))
                SetPrimaryKey(connection, t, tbl);
            else
                t.idProperty = idPropertyName;
            string pkey = HasAttr(t, "idProperty") ? t.idProperty : null;

            GetFieldInfo(connection, fields, validators, tbl, pkey);

            t.fields = fields;

            var activeValidators = validationColumns==null ? null : validators.Where(v => Enumerable.Contains(validationColumns, v.field));
            if (activeValidators!=null && activeValidators.Count() > 0)
                t.validators = validators.Where(v => v.isActive);
            if (includeMetaData)
            {
                t.tableMetaData = validators.Select(v => new
                {
                    name = v.field,
                    maxLength = v.type=="length" ? v.max : ushort.MaxValue,
                    mandatory = v.type=="presence" ? true : false
                });
            }               
            return t;
        }

        private static void SetPrimaryKey(OleDbConnection connection, dynamic t, string tbl)
        {
            string sql = @"SELECT column_name FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE OBJECTPROPERTY(OBJECT_ID(constraint_name), 'IsPrimaryKey') = 1 AND table_name = '"+tbl+"'";
        
            OleDbCommand cmd = new OleDbCommand(sql, connection);
            OleDbDataReader r = cmd.ExecuteReader();
            if (r.Read())
            {
                t.idProperty = r.GetString(r.GetOrdinal("column_name"));
            }
            r.Close();
        }

        private static void GetFieldInfo(OleDbConnection connection, List<dynamic> fields, List<dynamic> validators, string name, string pkeyName)
        {
            string sql = "SELECT column_name,is_nullable,data_type,character_maximum_length from information_schema.columns WHERE table_name = '" + name + "' ORDER BY ordinal_position";
            OleDbCommand cmd = new OleDbCommand(sql, connection);

            OleDbDataReader r = cmd.ExecuteReader();
            bool infoFound = false;
            while (r.Read())
            {
                infoFound = true;
                // GetFieldInfo fields
                bool nullable = r.GetString(r.GetOrdinal("is_nullable")) == "YES";
                string tname = r.GetString(r.GetOrdinal("data_type"));
                string typeName = TypeNameFromDatabaseType(tname);
                if (string.IsNullOrEmpty(typeName))
                {
                    Console.WriteLine("The datatype '" + tname + "' could not translated to an ExtJS data type");
                    continue;
                }

                string colName = r.GetString(r.GetOrdinal("column_name"));

                if (columns!=null && columns.Contains(colName))
                {
                    continue;
                }

                dynamic mf = BuildField(colName, typeName);
                mf.useNull = nullable;
                fields.Add(mf);

                //bool doValidation = validationColumns!=null;

                //if (doValidation)
                //{
                //    if (excludeValidation)
                //    {
                //        doValidation = !validationColumns.Contains(colName);
                //    }
                //    else
                //    {
                //        doValidation = validationColumns.Contains(colName) || validationColumns.Length == 0;
                //    }
                //}

                // Get validators
                object len = r.GetValue(r.GetOrdinal("character_maximum_length"));
                bool hasLen = len.GetType() != typeof(System.DBNull);
                bool lenValidator = (hasLen && ((int)len) > 0);

                if (colName != pkeyName && (lenValidator || !nullable))
                {
                    dynamic val = new ExpandoObject();
                    val.field = colName;
                    if (lenValidator)
                    {
                        val.field = colName;
                        val.type = "length";
                        if (hasLen)
                            val.max = (int)len;
                    }
                    if (!nullable)
                    {
                        val.type = "presence";
                    }
                   
                    validators.Add(val);                   
                }

            }
            r.Close();

            if (!infoFound)
                Console.WriteLine("Could not find any information on the table '" + name + "'");

        }

        private static string TypeNameFromDatabaseType(string type)
        {
            //if (nullable)
            //    return "auto";

            if (type == "int")
                return "int";
            else if (type == "varchar" || type == "nvarchar" || type == "char" || type == "text" || type == "ntext")
                return "string";
            else if (type == "datetime")
                return "date";
            else if (type == "bit")
                return "boolean";
            else if (type == "float")
                return "float";

            return "auto";
        }


    }

#endregion

}
